{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"project3\"\n",
        "format: html\n",
        "---\n",
        "\n",
        "\n",
        "## Objective\n",
        "\n",
        "Can we predict a playerâ€™s performance/worth in an upcoming season based on their previous performance stats and other metrics?\n",
        "\n",
        "## Description of Data\n",
        "\n",
        "We have data from qualified (300+ PAs) batters in each season from 2015 to 2024. Most of it is from Statcast but we also added the columns WAR (wins above replacement), R (runs), OPS+ (on-base plus slugging), rOBA (run-out batting average), and Rbat+ from Baseball Reference. We will predict a player's WAR in an upcoming season given their previous stats and stats from all other MLB players. The most important factors in this prediction will be WAR, Age, OPS (on-base plus slugging), xBA (expected batting average), Barrel%, K%, BB%, Rbat+ (weighted runs created +), and HR (homeruns).\n",
        "\n",
        "## Exploratory Data Analysis\n",
        "\n",
        "Data cleaning (details listed in Project 2/eda.qmd):\n"
      ],
      "id": "1cd8d067"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import os\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from scipy.stats import pearsonr\n",
        "\n",
        "def concat_statcast(input1, input2, output):\n",
        "  try:\n",
        "    df1 = pd.read_csv(input1)\n",
        "    df2 = pd.read_csv(input2)\n",
        "    combined_df = pd.concat([df1, df2], ignore_index=True)\n",
        "    combined_df.to_csv(output, index=False)\n",
        "  except:\n",
        "    print(\"file not found error\")\n",
        "    \n",
        "input1 = \"Statcast.csv\"\n",
        "input2 = \"Statcast_2020.csv\"\n",
        "output = \"Complete_Statcast.csv\"\n",
        "concat_statcast(input1, input2, output)\n",
        "\n",
        "def merge_data(input3, input4, output, columns):\n",
        "  try:\n",
        "    df1 = pd.read_csv(input3)\n",
        "    df1['Player'] = df1['last_name, first_name'].str.split(', ').str[::-1].str.join(' ')\n",
        "    all_years_df = []\n",
        "    for i in input4:\n",
        "      filename = f'{i}.csv'\n",
        "      df2 = pd.read_csv(filename, skiprows=4, skipfooter=3, engine='python')\n",
        "      df2['year'] = i \n",
        "      df2['Player'] = df2['Player'].str.replace(r'[*#]', '', regex=True).str.strip()\n",
        "      df2_subset = df2[['Player', 'year'] + columns]\n",
        "      all_years_df.append(df2_subset)\n",
        "    combined_df2 = pd.concat(all_years_df, ignore_index=True)\n",
        "    merged_df = pd.merge(df1, combined_df2, on=['Player', 'year'], how='inner')\n",
        "    merged_df.to_csv(output, index=False)\n",
        "    print(merged_df.info)\n",
        "  except FileNotFoundError:\n",
        "    print(\"file not found error\")\n",
        "    \n",
        "input3 = 'Complete_Statcast.csv'\n",
        "input4 = range(2015, 2025)\n",
        "columns = ['WAR', 'R', 'OPS+', 'rOBA', 'Rbat+']\n",
        "output = \"Complete_Data.csv\"\n",
        "merge_data(input3, input4, output, columns)\n",
        "complete_dataset = pd.read_csv(output)\n",
        "\n",
        "key_columns = ['xba', 'barrel_batted_rate', 'player_age', 'WAR', 'k_percent', 'bb_percent', 'on_base_plus_slg', 'Rbat+']"
      ],
      "id": "a74fb284",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Univariate Analysis (Histograms)\n"
      ],
      "id": "3bc91075"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Univariate Analysis\n",
        "print(data[key_columns].describe())\n",
        "\n",
        "# Histograms\n",
        "plt.figure(figsize=(16, 12))\n",
        "for i, col in enumerate(key_columns, 1):\n",
        "    plt.subplot(3, 3, i)\n",
        "    sns.histplot(data[col], kde=True, bins=30)\n",
        "    plt.title(f'Distribution of {col}')\n",
        "    plt.xlabel(col)\n",
        "    plt.ylabel('Frequency')\n",
        "plt.tight_layout()\n",
        "plt.savefig('univariate.png')\n",
        "plt.close()"
      ],
      "id": "edb0a5ab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can see that most of the data is either centered or skewed left.\n",
        "\n",
        "### Bivariate Analysis (Correlation)\n"
      ],
      "id": "e11e3737"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(data[key_columns].corr())\n",
        "\n",
        "plt.figure(figsize=(12, 8))\n",
        "# xBA vs WAR\n",
        "plt.subplot(2, 2, 1)\n",
        "sns.scatterplot(x='xba', y='WAR', data=data)\n",
        "plt.title('xBA vs WAR')\n",
        "# Barrel% vs OPS\n",
        "plt.subplot(2, 2, 2)\n",
        "sns.scatterplot(x='barrel_batted_rate', y='WAR', data=data)\n",
        "plt.title('Barrel% vs WAR')\n",
        "# Age vs WAR\n",
        "plt.subplot(2, 2, 3)\n",
        "sns.scatterplot(x='player_age', y='WAR', data=data)\n",
        "plt.title('Player Age vs WAR')\n",
        "# K% vs BB%\n",
        "plt.subplot(2, 2, 4)\n",
        "sns.scatterplot(x='Rbat+', y='WAR', data=data)\n",
        "plt.title('Rbat+ vs WAR')\n",
        "plt.tight_layout()\n",
        "plt.savefig('bivariate.png')\n",
        "plt.close()"
      ],
      "id": "fdfc6936",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can see that xBA vs WAR and Rbat+ vs WAR are somewhat positively correlated but Player Age vs WAR and Barrel% vs WAR are not strongly correlated.\n",
        "\n",
        "### Multivariate Analysis (Pairplot)\n"
      ],
      "id": "fe184363"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "sns.pairplot(data[key_columns], diag_kind='kde', corner=True)\n",
        "plt.suptitle('Pair Plot of Key Variables')\n",
        "plt.savefig('multivariate.png')\n",
        "plt.close()"
      ],
      "id": "9ab663b6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can see that for every plot most of the data points are clustered in a small area, with a few data points around that cluster. We can also see that the plots we expect to see positive correlation in such as WAR vs xBA, OPS vs BB%, etc. are indeed somewhat positively correlated while there are others that do not seem too correlated.\n",
        "\n",
        "The resulting png files are in Project 1 -> Data.\n",
        "\n",
        "### Modeling\n",
        "\n",
        "We will be using Recurrent Neural Networks as our main model. Before we start modeling, however, we must clean the data so we have sequences of seasons for each player. \n",
        "\n",
        "\n",
        "def rnn_prediction(input, output, target, key_columns, sequence_length):\n",
        "  # Sort by Player and Season\n",
        "  complete_dataset = complete_dataset.sort_values(['Player', 'year'], ascending=[True, True])\n",
        "  # Filter players with >3 seasons\n",
        "  season_counts = complete_dataset.groupby('Player')['year'].nunique()\n",
        "  valid_players = season_counts[season_counts > sequence_length].index\n",
        "  # Create sequences\n",
        "    X, y, player_years = [], [], []\n",
        "    for player in valid_players:\n",
        "        player_df = df[df['Player'] == player].loc[:, key_columns].copy()\n",
        "        seasons = len(player_df)\n",
        "        for i in range(seasons - sequence_length):\n",
        "            seq = player_df.iloc[i:i+sequence_length].values\n",
        "            if seq.shape != (sequence_length, 8):\n",
        "                continue\n",
        "            X.append(seq)\n",
        "            y.append(df[df['Player'] == player][target].iloc[i+sequence_length])\n",
        "            player_years.append((player, df[df['Player'] == player]['year'].iloc[i+sequence_length]))\n",
        "    \n",
        "    if not X:\n",
        "        raise ValueError(f\"No valid sequences created with sequence_length. Found {len(valid_players)} players with >3 seasons.\")\n",
        "    \n",
        "    X = np.array(X)\n",
        "    y = np.array(y)\n",
        "    \n",
        "    # Scale features and target\n",
        "    scaler_X = StandardScaler()\n",
        "    scaler_y = StandardScaler()\n",
        "    X_reshaped = X.reshape(-1, 8)\n",
        "    X_scaled = scaler_X.fit_transform(X_reshaped).reshape(X.shape)\n",
        "    y_scaled = scaler_y.fit_transform(y.reshape(-1, 1)).flatten()\n",
        "    \n",
        "    # Split data\n",
        "    train_idx = int(0.8 * len(X))\n",
        "    X_train, X_test = X_scaled[:train_idx], X_scaled[train_idx:]\n",
        "    y_train, y_test = y_scaled[:train_idx], y_scaled[train_idx:]\n",
        "    test_player_years = player_years[train_idx:]\n",
        "    \n",
        "    # Build RNN model\n",
        "    model = Sequential([\n",
        "        LSTM(50, input_shape=(sequence_length, 8), return_sequences=False),\n",
        "        Dense(25, activation='relu'),\n",
        "        Dense(1)\n",
        "    ])\n",
        "    model.compile(optimizer='adam', loss='mse')\n",
        "    \n",
        "    # Train model\n",
        "    model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=0, validation_split=0.2)\n",
        "    \n",
        "    # Predict\n",
        "    y_pred_scaled = model.predict(X_test)\n",
        "    y_pred = scaler_y.inverse_transform(y_pred_scaled).flatten()\n",
        "    y_test_orig = scaler_y.inverse_transform(y_test.reshape(-1, 1)).flatten()\n",
        "    \n",
        "    # Evaluate\n",
        "    rmse = np.sqrt(mean_squared_error(y_test_orig, y_pred))\n",
        "    r2 = r2_score(y_test_orig, y_pred)\n",
        "    \n",
        "    # Save predictions\n",
        "    test_df = pd.DataFrame({\n",
        "        'Player': [py[0] for py in test_player_years],\n",
        "        'Year': [py[1] for py in test_player_years],\n",
        "        'Actual_WAR': y_test_orig,\n",
        "        'Predicted_WAR': y_pred\n",
        "    })\n",
        "    test_df.to_csv(output, index=False)\n",
        "    \n",
        "    return model, test_df, rmse, r2"
      ],
      "id": "9817b060"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}